# **Тестовое задание для JustMoby**


## **Общая информация**
**Формулировка задания:** (будет здесь, если мне разрешат опубликовать ее)

**Дата получения:** 29 сентября 2025

**Максимальное время выполнения:** 1 неделя (не было уточнения, рабочая или календарная)

**Фактические даты выполнения задания:** 1 октября - 5 октября (включительно)

**Затраченное время:**
- Фактическое на разработу - 38 часов 17 минут _(были две очень долгих сессии: одна на 11 часов, вторая почти на 10 часов :) )_
- Написание ридми и комментариев в коде - 00 ч 40 минут
- Количество запросов к нейросетям - 0
- Количество запросов в гугл - много :)

**Версия редактора Unity:** 2022.3.52f1

Можно смотреть с ветки `main`.


## **Общие впечатления от выполнения**

Прикольное тестовое, которое внезапно немного выбило из колеи и местами даже заставило сомневаться в собственном опыте :)

К сожалению, не успел сделать все геймдизайнейрские хотелки, но, вроде, получилось учесть все требования высокого приоритета.

При чтении и в начале выполнения выделил для себя несколько основных пунктов:
- **Баланс (конфигурация)** - надо предусмотреть возможность подтаскивать баланс не только из конфигов (`ScriptableObject-ов`), но и из других источников. В самом тестовом можно было использовать как раз конфиги. Я уже делал реализацию баланса на `JSON-ах`, которые парсятся в баланс модели, тут было не сложно.
- **Скролл кубиков** - ну, казалось, скролл как скролл, но не все так просто. Более подробно будет расписано чуть дальше.
- **Drag and Drop кубиков** - оказался самой большой проблемой, т.к. по работе я его делал <ins>**РОВНО ОДИН РАЗ**</ins>, а в домашних проектах <ins>**НЕ ДЕЛАЛ ВООБЩЕ НИКОГДА**</ins>. Хорошо, что под рукой оказались исходники проекта с последнего места работы, можно было там подсмотреть.
- **Строительство башни** - вот здесь я срезал больше всего углов >_<, так как самые сложные и принципиальные вопросы возникли только когда я дошел до этой механики, и спрашивать там уже было совсем неприлично.
- **Добавление / удаление кубиков, взаимодействие с дырой** - в целом, после реализации нормального драг-н-дропа все оказалось довольно просто. А, ну и тут срезал один угол, так как зарылся в детали и не смог разрешить самостоятельно один всратый момент.
- **Анимирование** - `DOTween` наше все :)
- **Сохранение прогресса** - эта механика не была в числе требований высокого приоритета, поэтому я ее скипнул. Блин, да при реализации с нуля нужна примерно **неделя фуллтайм работы** (примерно столько я ее и писал самостоятельно когда-то в домашнем проекте), а изучать готовые решения тоже времени не было.

Графику использовал предоставленную в `Figma`. Кстати, с тем набором графики не получится реализовать "падение" кубика в дыру, как на референсе (либо там надо будет капец как заморочиться, что, скорее всего, просто не стоит того), потому что при экспорте дыра идет <ins>**вместе**</ins> с тенюшкой снизу, а они, по-хорошему, должны быть отдельными спрайтами.


## **Техническая часть и комментарии**

Начну с самого важного - точки входа:
- `ProjectInstaller` - базовый инсталлер проекта, там биндятся сервисы, которые будут доступны из любой другой сцены
- `ProjectServiceIniter` - инициализатор базовых сервисов проекта
- `CubeTowerGameSceneInstaller` - инсталлер сцены игры про башню кубиков
- `CubeTowerGameSceneServiceIniter` - инициализатор сервисов сцены игры про башню кубиков
- `CubeTowerGameSceneController` - контроллер сцены игры про башню кубиков

А вот дальше я не знаю, о чем написать, поэтому предлагаю более подробно пройти по каждому основных пунктов задания, которые были описаны в разделе "Общие впечатления".


### **Баланс**

Классы:
- `BalanceModel` - базовая баланс модель какого-нибудь объекта
- `BalanceModelWithId` - баланс модель с текстовым ID
- `BalanceModelWithIdConfigItem` - баланс модель, которая заполняется данными из конфиг итема, который хранится в `ScriptableObject-е`
- `BalanceStorageScriptableObject` - хранилище баланс моделей, которое заполняется из `ScriptableObject-а`
- `BalanceService` - абстрактный класс баланс сервиса, через который можно получить доступ к хранилищам баланса и баланс моделям
- `ProjectBalanceService` - базовый баланс сервис проекта, через него можно получить доступ к балансным данным из любой сцены
- `CubeTowerGameBalanceService` - баланс сервис сцены игры про башню кубиков, через него можно получить доступ к балансным данным этой игры

В тестовом задании было требование, по которому нужно учесть, что источником конфигурации игры могу стать разные источники данных. Я думаю, что выполнил это требование, так как достаточно добавить другие вариации балансных хранилищ, которые будут предоставлять доступ к балансным данным из других источников, и дело в шляпе :)

Я сам предпочитаю, когда балансные данные идут из одного источника, например из `JSON-а`, который потом парсится в баланс модели объектов или конфигов.


### **Скролл кубиков**

Классы:
- `GameView` - главное окно игры
- `CubeScrollWidget` - скрипт виджета скролла кубиков
- `CubeTowerGameSceneObjectPoolService` - сервис, объединяющий все объектные пулы сцены игры про башню кубиков
- `CubeWidget` - базовый виджет кубика
- `CubeScrollDraggableWidget` - виджет кубика из скролла, который поддерживает драг-н-дроп механику

Скролл с объектами внутри своего контента, казалось бы, является очень распространенной частью почти любой игры. Но скролл в тестовом задании является не самым обычным, так как объекты внутри его контента должны драг-н-дропатся. Я постарался учесть специфику целевой аудитории игры, и сделал так, что скроллить скролл можно и через виджеты кубиков. Однако если потянуть кубик вверх - то тут уже включится драг-н-дроп механика и появится силуэт нового кубика :) 

Кстати, о драг-н-дропе...

### **Drag and Drop кубиков**

Или история о том, как:
- потратить примерно 5 часов где-то в начале в попытке сделать стильно-модно-молодежно, используя новую `Unity Input System`, в итоге забить и немного стащить решение из рабочего проекта, использующий легаси `Unity Input Manager`
- потратить еще примерно 5 часов в последний день на улучшение решения с работы и адаптацию его к канвасам с `Render Mode - Camera`


