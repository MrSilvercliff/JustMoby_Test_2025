# **[Тестовое задание для JustMoby]**


## **[Общая информация]**
**Формулировка задания:** (будет здесь, если мне разрешат опубликовать ее)

**Дата получения:** 29 сентября 2025

**Максимальное время выполнения:** 1 неделя (не было уточнения, рабочая или календарная)

**Фактические даты выполнения задания:** 1 октября - 5 октября (включительно)

**Затраченное время:**
- Фактическое на разработу - 38 часов 17 минут _(были две очень долгих сессии: одна на 11 часов, вторая почти на 10 часов :) )_
- Написание ридми и комментариев в коде - 00 ч 40 минут
- Количество запросов к нейросетям - 0
- Количество запросов в гугл - много :)

**Версия редактора Unity:** 2022.3.52f1

Можно смотреть с ветки `main`.


## **[Общие впечатления от выполнения]**

Прикольное тестовое, которое внезапно немного выбило из колеи и местами даже заставило сомневаться в собственном опыте :)

К сожалению, не успел сделать все геймдизайнейрские хотелки, но, вроде, получилось учесть все требования высокого приоритета.

При чтении и в начале выполнения выделил для себя несколько основных пунктов:
- **Баланс (конфигурация)** - надо предусмотреть возможность подтаскивать баланс не только из конфигов (`ScriptableObject-ов`), но и из других источников. В самом тестовом можно было использовать как раз конфиги. Я уже делал реализацию баланса на `JSON-ах`, которые парсятся в баланс модели, тут не было каких-либо сложностей.
- **Скролл кубиков** - ну, казалось, скролл как скролл, но не все так просто. Более подробно будет расписано чуть дальше.
- **Drag and Drop кубиков** - оказался самой большой проблемой, т.к. по работе я его делал <ins>**РОВНО ОДИН РАЗ**</ins>, а в домашних проектах <ins>**НЕ ДЕЛАЛ ВООБЩЕ НИКОГДА**</ins>. Хорошо, что под рукой оказались исходники проекта с последнего места работы, можно было там подсмотреть.
- **Строительство башни** - вот здесь я срезал больше всего углов, так как самые сложные и принципиальные вопросы возникли только когда я дошел до этой механики, и спрашивать там уже было совсем неприлично.
- **Добавление / удаление кубиков, взаимодействие с дырой** - в целом, после реализации нормального драг-н-дропа все оказалось довольно просто. А, ну и тут срезал один угол, так как зарылся в детали и не смог разрешить самостоятельно один всратый момент.
- **Анимирование** - `DOTween` наше все :)
- **Локализация** - здесь тоже не испытал каких-либо сложностей, потому что когда-то сделал свою реализацию локализации с хранением текстов в `JSON-ах` и есть опыт работы с готовыми решениями. При выполнение подключил как раз свою реализацию
- **Сохранение прогресса** - эту механику я просто не успел сделалть, хотя уже был опыт самостоятельной реализации с сохранением в `JSON`.

Графику использовал предоставленную в `Figma`. Кстати, с тем набором графики не получится реализовать "падение" кубика в дыру, как на референсе (либо там надо будет капец как заморочиться, что, скорее всего, просто не стоит того), потому что при экспорте дыра идет <ins>**вместе**</ins> с тенюшкой снизу, а они, по-хорошему, должны быть отдельными спрайтами.


## **[Техническая часть и комментарии]**

Начну с самого важного - точки входа:
- `ProjectInstaller` - базовый инсталлер проекта, там биндятся сервисы, которые будут доступны из любой другой сцены
- `ProjectServiceIniter` - инициализатор базовых сервисов проекта
- `CubeTowerGameSceneInstaller` - инсталлер сцены игры про башню кубиков
- `CubeTowerGameSceneServiceIniter` - инициализатор сервисов сцены игры про башню кубиков
- `CubeTowerGameSceneController` - контроллер сцены игры про башню кубиков

А вот дальше я не знаю, о чем написать, поэтому предлагаю более подробно пройти по каждому основных пунктов задания, которые были описаны в разделе "Общие впечатления".


### **[Баланс]**

Классы:
- `BalanceModel` - базовая баланс модель какого-нибудь объекта
- `BalanceModelWithId` - баланс модель с текстовым ID
- `BalanceModelWithIdConfigItem` - баланс модель, которая заполняется данными из конфиг итема, который хранится в `ScriptableObject-е`
- `BalanceStorageScriptableObject` - хранилище баланс моделей, которое заполняется из `ScriptableObject-а`
- `BalanceService` - абстрактный класс баланс сервиса, через который можно получить доступ к хранилищам баланса и баланс моделям
- `ProjectBalanceService` - базовый баланс сервис проекта, через него можно получить доступ к балансным данным из любой сцены
- `CubeTowerGameBalanceService` - баланс сервис сцены игры про башню кубиков, через него можно получить доступ к балансным данным этой игры

В тестовом задании было требование, по которому нужно учесть, что источником конфигурации игры могу стать разные источники данных. Я думаю, что выполнил это требование, так как достаточно добавить другие вариации балансных хранилищ, которые будут предоставлять доступ к балансным данным из других источников, и дело в шляпе :)

Я сам предпочитаю, когда балансные данные идут из одного источника, например из `JSON-а`, который потом парсится в баланс модели объектов или конфигов.


### **[Скролл кубиков]**

Классы:
- `GameView` - главное окно игры
- `CubeScrollWidget` - скрипт виджета скролла кубиков
- `CubeTowerGameSceneObjectPoolService` - сервис, объединяющий все объектные пулы сцены игры про башню кубиков
- `CubeWidget` - базовый виджет кубика
- `CubeScrollDraggableWidget` - виджет кубика из скролла, который поддерживает драг-н-дроп механику

Скролл с объектами внутри своего контента, казалось бы, является очень распространенной частью почти любой игры. Но скролл в тестовом задании является не самым обычным, так как объекты внутри его контента должны драг-н-дропатся. Я постарался учесть специфику целевой аудитории игры, и сделал так, что скроллить скролл можно и через виджеты кубиков. Однако если потянуть кубик вверх - то тут уже включится драг-н-дроп механика и появится силуэт нового кубика :) 

Кстати, о драг-н-дропе...


### **[Drag and Drop кубиков]**

Или история о том, как:
- потратить примерно 5 часов где-то в начале в попытке сделать стильно-модно-молодежно, используя новую `Unity Input System`, в итоге забить и немного стащить решение из рабочего проекта, использующий легаси `Unity Input Manager`
- потратить еще примерно 5 часов в последний день на улучшение решения с работы и адаптацию его к канвасам с `Render Mode - Camera`

Классы:
- `KeyboardMouseInputController` - контроллер инпута от мышки и клавиатуры
- `GameDragAndDropController` - контроллер драг-н-дропа для `GameView`
- `GameDragAndDropPanel` - дран-н-дроп панель внутри `GameView`
- `MonoUpdater` - общий и единственный апдейтер, который ловит `Update`, `FixedUpdate`, `LateUpdate` и вызывает ручной апдейт всех объектов, которые на него подписаны
- `CubeScrollDraggableWidget` - виджет кубика, поддерживающий драг-н-дроп

В общем, как уже писал выше, я драг-н-дроп делал не очень часто, поэтому решил подсмотреть реализацию в проекте с предыдущего места работы. Подсмотрел, а там легаси `Unity Input Manager`. Я хотел переделать на новую `Unity Input System`, но в процессе немного "поплыл" и решил, что лучше оставлю реализацию на легаси `Input Manager-е`. А еще `GameDragAndDropController` получился немного God-object-ом, потому что через него происходит почти весь геймплей игры.


### **[Строительство башни]**

Классы:
- `CubeTowerService` - главный сервис для работы с башнями кубиков, своеобразная входная точка в эту фичу. Надо инъектировать именно его, чтобы взаимодествовать с этой механикой.
- `CubeTowerRepository` - репозиторий башен, хранит в себе активные башенки и может выдать их по каким-нибудь правилам
- `CubeTowerBuildService` - через этот сервис происходит "строительство" и "уничтожение" башен кубиков. Строительство вызывается при добавлении первого кубика в "зону постройик", уничтожение вызывается при удалении последнего кубика башни. 
- `CubeTowerAddCubeService` - через этот сревис происходит добавление и изъятие кубиков из башен
- `CubeTowerBuildAreaWidget` - виджет зоны постройки башен кубиков. Дроп кубика из скролла внутри этой зоны вызовет постройку башни
- `CubeTowerWidget` - виджет башни кубиков
- `CubeTowerCubeWidget` - виджет кубика башни кубиков

Работа с башнями кубиков показалась довольно простой, когда я читал задание. Но на деле все оказалось вообще непросто, и вот почему:

**"Первый кубик можно поставить в любое место правой верхней части экрана"** (правая часть - это та самая зона постройки башни) - здесь кроется первый подводный камень. 

Дело в том, что кубик можно дропнуть достаточно близко к границе зоны, и здесь есть два варианта поведения: 
- башня начинает строиться на фактическом месте дропа и может "залезть" на границу между разными частями экрана как первым кубиком, так и другими, учитывая момент рандомного смещения кубиков при добавлении в башню
- должно произойти смещение башни на достаточное расстояние, чтобы первый кубик оказался внутри "своей" зоны экрана, и еще рандомное смещение не должно вызвать "наезд" кубика на другую часть экрана.

В итоге я решил, что второй вариант слишком сложен для тестового задания, а первый вариант будет выглядеть слишком некрасиво, поэтому немного сделал нечто среднее: первый кубик действительно можно дропнуть в любую часть "своей" зоны, но башня начнет строиться в строго определенном месте примерно в центре этой зоны.

**"Кубики ставятся поверх предыдущих в башню со случайным смещением по горизонтали, но не более 50% длины грани"** - тут кроется еще один подводный камень.

Здесь у нас может быть:
- действительно честный рандом со смещением каждого следующего кубика в башни, который может привести к довольно нереалистичной фигуре башни
- рандомиться будет только степень смещения, а направление смещения будет строго чередоваться, чтобы башня выглядела более менее реалистичной

Первый вариант приведет к тому, что при удалении кубика придется подтягивать те, что были выше, к тем, что остались ниже удаленного. А если удаляем самый нижний - либо подтягивать все остальные к "центру башни", либо ничего и не делать, и оставшаяся часть башни немного "уедет" в сторону. Звучит опять слишком сложно для тестового задания.

Второй вариант не обладает проблемами первого, но тогда "случайность" получается не слишком честной, и к этому можно придраться :)

В итоге я вообще решил отказаться от механики смещения кубиков, так как она сама по себе является чисто визуальной штукой, чем каким-то важным геймплейным аспектом.


### **[Добавление / удаление кубиков, взаимодействие с дырой]**

Классы:
- `CubeTowerService` - главный сервис для работы с башнями кубиков, своеобразная входная точка в эту фичу. Надо инъектировать именно его, чтобы взаимодествовать с этой механикой.
- `CubeTowerRepository` - репозиторий башен, хранит в себе активные башенки и может выдать их по каким-нибудь правилам
- `CubeTowerBuildService` - через этот сервис происходит "строительство" и "уничтожение" башен кубиков. Строительство вызывается при добавлении первого кубика в "зону постройки", уничтожение вызывается при удалении последнего кубика башни. 
- `CubeTowerAddCubeService` - через этот сревис происходит добавление и изъятие кубиков из башен
- `CubeTowerBuildAreaWidget` - виджет зоны постройки башен кубиков. Дроп кубика из скролла внутри этой зоны вызовет постройку башни
- `CubeTowerWidget` - виджет башни кубиков
- `CubeTowerCubeWidget` - виджет кубика башни кубиков

По этой части задания не могу сказать что-то особенное. Каких-либо сложностей с реализацией не возникло. Единственный момент - немного сомневаюсь в производительности `PolygonCollider2D.OverlapPoint()`, но это единственный коллайдер на всю сцену, а геймплей довольно примитивный, поэтому тут все должно быть хорошо. Единственный срезанный угол здесь уже был описан выше :)


### **[Анимирование]**

Классы:
- `DOTweenVFXPanel` - отдельный канвас, внутри которого происходят все DOTween анимации
- `CubeDisappearDOTweenPanel` - виджет, ответственный за анимацию исчезновение кубика при его неудачном дропе мимо башни/дыры
- `CubeMoveToHoleDOTweenPanel` - виджет, ответственный за анимацию выбрасывания кубика в дыру
- `ShowTextDOTweenPanel` - виджет, ответственный за анимацию текста
- `DOTweenSequenceService` - основной сервис для вызова DOTween анимаций игры
- `DOTweenSequenceData` - объект, содержащий в себе информацию о DOTween анимации, которую необходимо воспроизвести
- `DOTweenSequenceDataRepository` - репозиторий `DOTweenSequenceData`
- `DOTweenSequenceDataCreator` - класс, через который создаются `DOTweenSequenceData`
- `DOTweenHelper` - небольшой статический класс-хелпер с утилити функциями для удобной работы с DOTween.

В задании просили сделать хотя бы одну анимацию, я сделал три, если анимацию текста считать полноценной отдельной анимацией, а не довеском к основной анимации с кубиками. Вообще у меня получился вот такой список:
- добавление первого кубика в башню 
- добавление дополнительного кубика в башню _(описана в самом задании)_
- выбрасывание кубика в дыру **(сделал)**
- исчезание кубика при дропе мимо башны/дыры **(сделал)**
- анимация текста **(сделал)**
- смещение кубиков вниз при удалении кубика башни _(описана в самом задании)_
- возвращение кубика в башню при дропе его мимо дыры 

Для анимаций я сделал отдельный канвас, как-то так было принято в прошлых компаниях. Плюс это позволяло отделить всякие чисто визуальные анимации от основного геймплея и отображать их всегда поверх этого самого геймплея. В остальном про данную часть задания тоже не могу сказать что-то особенное. Делал их почти в последнюю очередь, так как сперва геймплей :)

### **[Локализация]**

Классы:
- `LocalizationService` - основной сервис локализации
- `LocalizationConfig` - конфиг локализации, хранит в себе всякие настройки локализации
- `LocalizationHelper` - небольшой статический класс-хелпер, в который вынес основные ключи локализации

Обычно локализацию я встраиваю на более ранней стадии разработки проекта, но тут добавлял ее в последнюю очередь, так как единственный текст в игре появился как раз на стадии анимирования. Здесь используется довольно старая версия моей реализации, в которой весь текст подгружается при инициализации. В последней версии я сделал разделение на прелоад и рантайм локализацию: первая подгружается при инициализации, а вторая только при необходимости из аддрессаблов.

Сохранение прогресса я не успел сделать, поэтому останавливаться на нем в отдельном пункте уже не буду.
